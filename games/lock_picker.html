<!--wikipedia on some common color spectra: https://en.wikipedia.org/wiki/List_of_monochrome_and_RGB_color_formats#3-bit_RGB -->
<!-- The 3 bit colors can be used using the following css colors: "red","lime","blue","magenta", "yellow" and "cyan" (and also "black" and "white") -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#00c5d3"/>
    <meta name="Description" content="Arcade minigame about lock picking.">
    <meta name="keywords" content="JavaScript, game, arcade, opensource, lockpicker, pwa">

    <link rel="icon" href="../resources/icons/favicon.ico">
    <link rel="icon" href="../resources/icons/favicon.svg" type="image/svg+xml">
    <link rel="mask-icon" href="../resources/icons/icon_apple_pinned_tab.svg" color="#FF961D">
    <link rel="apple-touch-icon" href="../resources/icons/icon180_mask.png">
    <title>Lock picker game</title>

    <link rel="stylesheet" href="../w3.css">
</head>
<body>    
<!--sidebar-->
<div class="w3-col l2 m2 s4">
    <!--include icon with link to the minigames homepage-->
     <div style="width: 50%; position: relative;z-index:1; margin:10px;">
         <a href="../index.html"  style="position:relative;z-index:1;"> 
             <img src="../resources/icons/icon_transparent.svg" alt="JS minigames home" title="JS Minigames Home"
             class="w3-circle w3-ripple hover-icon-bg" 
             style="width:100%;height:100%;max-width:100px; border-width:2px; border-style: solid;">
         </a>    
     </div>
 </div>
</body>

<style>
.hover-icon-bg:hover{
    background-color:#00c5d3;
}
</style>

<script>
    /* SOME CONSTRAINTS ON THE VARIABLES:
    *** Goalsize must be greater than player diameter, else collision detection may fail
    *** The Goalsize should also not be too large because otherwise the generation loaction constraints may never be met, crashing the game
    */

    /*  KNOWN ISSUES TO BE FIXED:
    *** collision detection (especially on mobile android) is not always accurate  
    */

    const code_version="1.3";

    var canvasEle=undefined; //var holding canvas
    var context; //canvas context
    var canvasEle_static=undefined; //var holding canvas for drawing static images
    var context2; //static canvas context

    //update the frame at constant framerate
    const fps=60; //desired frames per second
    var GameClk; //variable holding frame interval timer
    var GameTime=0; // gametime in frames
    var frametime={start:0.0, end:0.0, diff:function(){return this.end-this.start;}}; //start and end times of the previous frame, as well as the lenght of the frame (in ms)
    var avg_fps=0; //average fps

    var waitForListener=false;

    var GameState="play";// current state of the game. list of states: play, gameover

    var score=0; //number of hits the player made

    var player_angle=0;     //angle of the player (in rad)
    var playerCoord={x:150,y:250};
    const playerSpeed_init=0.08*60; //initial speed of the player. in rad/s
    const playerSpeed_final=1.5*0.08*60 ; //maximum (aka final) speed of the player. in rad/s
    var playerSpeed=playerSpeed_init; //playerspeed in rad per frame
    const playerRadius=15; //radius of the player in px
    var sign=1; //the sign of the direction the player is moving in

    var GoalPos=0; //lowest angle of the goal in rad
    const GoalSize_init=0.8; //inital goalsize (in rad)
    const GoalSize_final=0.35; //final goalsize (in rad)
    var GoalSize=GoalSize_init; //size of the goal in rad

    const default_ScreenSize={x:300, y:400}; //the for which the game animations were initially designed
    var screenCoord_scale=1.0;
    var translation_offset={x:0,y:0};

    //fallbackfunction for animation frame for maximum browser compatibility
    //change the defintion of requestAnimationFrame if the browser does not support it by default
    //from: https://gist.github.com/paulirish/1579671
    (function() {
    var lastTime = 0;
    var vendors = ['webkit', 'moz'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame =
          window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); },
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}());


    window.onload = () => {
        init();
    }

    //initialize the game after loading the script
    function init(){
        //generate fullscreen canvas
        sizeCanvas();

        //binding eventlisteners
        //mouseinputs
        canvasEle.addEventListener('mousedown', mouseDownListener);
        //touch inputs
        canvasEle.addEventListener('touchstart', mouseDownListener);

        //init variables
        initVars();

        //draw background frame
        drawFrame_static();

        //boot the game itself
        requestAnimationFrame(updateGamestate);
        //GameClk=setInterval(updateGamestate,1000/fps);

        //display the current version of the game
        console.log("Game version: " + code_version);
    }

    //set all game variabes to their initial state, so that the game can start over again
    function initVars(){
        GameState="play";
        score=0;
        player_angle=0;
        playerSpeed=playerSpeed_init;
        sign=1;
        GoalPos=0; //lowest angle of the goal in rad
        GoalSize=GoalSize_init; //size of the goal in rad

        //generate target
        generateGoal();
    }


    //full screen and resizing canvas: https://riptutorial.com/html5-canvas/example/7516/creating-a-responsive-full-page-canvas

    // Creates a canvas
    function createCanvas () {                
        const canvasEle = document.createElement("canvas"); 
        canvasEle.style.position = "absolute"; // Set the style 
        canvasEle.style.left     = "0px";      // Position in top left
        canvasEle.style.top      = "0px";
        canvasEle.style.zIndex   = 0;        
        document.body.insertAdjacentElement("beforeend",canvasEle);  // Add to document
        return canvasEle;
    }
    // Resizes canvas. Will create a canvas if it does not exist
        function sizeCanvas () {                
        if (canvasEle === undefined) {         // Check for global canvas reference
            canvasEle = createCanvas();        // Create a new canvas element
            context = canvasEle.getContext("2d");  // Get the 2D context

            //create copy of canvas to contain the static drawings
            canvasEle_static=canvasEle.insertAdjacentElement("beforebegin",canvasEle.cloneNode());
            context2 = canvasEle_static.getContext("2d" , { alpha: false });  // Get the 2D context           
        }
        canvasEle.width  = innerWidth;         // Set the canvas resolution to fill the page
        canvasEle.height = innerHeight;
        canvasEle_static.width  = innerWidth;         // Set the canvas resolution to fill the page
        canvasEle_static.height = innerHeight;
        
        //also change the scaling of the drawn elements
        setScreenCoord();
        setWindowTranslation();
    }
    //initialize the screen coordinates based on the screensize
    function setScreenCoord(){
        //set the scaling factor to the smaller of the x and y scaling factors
        var scale = canvasEle.width/default_ScreenSize.x;

        if(canvasEle.height/default_ScreenSize.y < scale){
            scale=canvasEle.height/default_ScreenSize.y;
        }

        scale=floor(scale, 1);

        //apply minimum scale
        if(scale<0.4){
            scale=0.4;
        }

        //set the global variable to its new value
        screenCoord_scale=scale;
    }

    //translate the window such that it is centered
    function setWindowTranslation(){
        translation_offset.x=(canvasEle.width-(default_ScreenSize.x)*screenCoord_scale)/2;
        translation_offset.y=(canvasEle.height-(default_ScreenSize.y)*screenCoord_scale)/2;
    }
    
    function ToScreenCoord(x,y){
        return {x: x*screenCoord_scale,y: y*screenCoord_scale};
    }

    function updateGamestate(){
        //measure frametime
        frametime.start=frametime.end;
        frametime.end=performance.now();

        GameTime++;
        switch(GameState){
            case "play": 
                if(!waitForListener){
                    //only change player coordinates if there is no collision detection running for the current set of coordinates
                    updatePlayer();
                }
                drawFrame();
            break;
            case "gameover": 
                drawFrame_Gameover();
            break;
            default: console.log("ERROR: The game is not is a valid state..."); 
            break;
        } 

        // display time between consecutive requestAnimationFrame events, also display time used to exectute the gamestate switch statement-for dubugging perposes
        /*let drawtime=performance.now()-frametime.end;
        if(GameTime<1000)
        {        
            console.log("frametime: "+frametime.diff()+ " drawtime: " + drawtime);
        }*/
        requestAnimationFrame(updateGamestate);
    }

     //declaring eventlisteners
     const mouseDownListener = (event)=>{
        waitForListener=true;
        switch(GameState){
            case "play": 
                //check whether it was a hit
                if(isCollision()){
                    //if yes, change the sign
                    sign*=-1;

                    //increase difficulty to play
                    nextLevel();
                    //generate new goal
                    generateGoal();
                    //increase score counter
                    score++;
                }
                else{
                    //if no, game over
                    GameState="gameover";
                 }
                break;
            case "gameover": 
                //restart the game
                initVars();
            break;
            default: console.log("ERROR: The game is not is a valid state..."); 
            break;
        }      
        event.preventDefault();
        waitForListener=false;
    }
    
    //calculate coordinates relative to canvas
    const getClientOffset = (event)=>{
        const {pageX, pageY}=event.touches ? event.touches[0]:event;
        
        const y=pageY-canvasEle.offsetTop;
        const x=pageX-canvasEle.offsetLeft;

        return {x,y};
    }

    const clearCanvas = ()=>{
        context.clearRect(0,0,canvasEle.width, canvasEle.height);
    }    

    //update the position of the player
    function updatePlayer(){
        player_angle+=sign*playerSpeed*(frametime.diff()/1000);
        playerCoord.x = 250 + 100*Math.cos(-1*player_angle);
        playerCoord.y = 230 + 100*Math.sin(-1*player_angle);
    }

    //increase the game's difficulty to match the higher level
    function nextLevel(){
        //decrease goal size
        const numSteps_goal=30; //number of steps goalsize take to reach final value
        const numSteps_speed=30; //number of steps (aka levels) to take between initial and maximum player speed

        //decrease goalsize
        //only start increasing difficulty after some level is reached  
        if(score>1){
            //only decrease until the final value is reached
            if(GoalSize>GoalSize_final)
            {
                GoalSize+= (GoalSize_final - GoalSize_init) /numSteps_goal;
            }
            else{
                GoalSize=GoalSize_final;
            }
        }

        //increase playerspeed
        //only start increasing difficulty after some level is reached      
        if(score>numSteps_goal - (numSteps_speed/4))
        {
            //only increase until the maximum value is reached
            if(playerSpeed<playerSpeed_final)
            {
                playerSpeed+= (playerSpeed_final - playerSpeed_init) /numSteps_speed;
            }
            else{
                playerSpeed=playerSpeed_final;
            }
        }
    }

    //generate new position for the goal
    function generateGoal(){
        let GoalPos_old=GoalPos;
        while((Math.abs(GoalPos-GoalPos_old)<GoalSize)){
            GoalPos = GoalPos_old -0.3*Math.PI + 1*Math.PI* Math.random();
        }
        if(GoalPos>2*Math.PI){
            GoalPos-=2*Math.PI;
        }
        if(GoalPos<0){
            GoalPos+=2*Math.PI;
        }
        if(GoalPos+GoalSize>2*Math.PI){
            GoalPos-=GoalSize;
        }
    }

    //checks for collision between player and goal
    function isCollision(){
        //calculate players angles
        var Angle_player_center=player_angle%(2*Math.PI);
        if(Angle_player_center>0){        
            Angle_player_center = -1*(Angle_player_center-(2*Math.PI));
        }        else{
            Angle_player_center *=-1;
        }

        var Angle_player_upper=Angle_player_center + Math.asin(playerRadius/100);
        var Angle_player_lower=Angle_player_center - Math.asin(playerRadius/100);

        var GoalPos_upper=GoalPos+GoalSize;

        if((Angle_player_upper>=GoalPos) &&(Angle_player_upper<=GoalPos_upper))
        {
            return true;
        }
        if((Angle_player_lower>=GoalPos) &&(Angle_player_lower<=GoalPos_upper))
        {
            return true;
        }

        //display angles (for debugging purposes)
       /*console.log("player angle center: "+Angle_player_center);
        console.log("player angle upper: "+Angle_player_upper);
        console.log("player angle lower: "+Angle_player_lower);
        console.log("goal angle: "+GoalPos);
        var temp=GoalPos+GoalSize;
        console.log("goal angle upper: "+temp);*/

        //draw angle from zero to center (for debugging purposes)
        /*context.beginPath();
        context.arc(250,250,100,0,Angle_player_center);
        context.strokeStyle="green";
        context.stroke();*/

        return false;
    }

    var prev_frametimes=[0,0,0,0,0,0,0,0,0,0];
    //calculate the average fps based on the last 10 frames
    //NOTE: it only works if the function is called more often than the prev_frametimes array is long. Basically you have to fill it first by calling the function a number of times.
    function avgFPS(latest_frametime){
        //update the frametime database array
        prev_frametimes.shift();
        prev_frametimes.push(latest_frametime);

        //calculate average
        var sum=0; //the average
        for (i in prev_frametimes){
            sum+=prev_frametimes[i];
        }
        return 1000/(sum/prev_frametimes.length); //return the average
    }
 
    //draw the static 'background' of the game
    //this includes the actual background but also the immobile parts of the lock
    function drawFrame_static(){          
        //entire canvas ref frame
        //clear the canvas
        context2.clearRect(0,0,canvasEle.width, canvasEle.height);

        //canvas background
        context2.beginPath();
        context2.rect(0,0,canvasEle.width, canvasEle.height);
        context2.fillStyle="cyan";
        context2.fill();

        //game ref frame
        context2.translate(translation_offset.x,translation_offset.y);
        //scale the drawings
        context2.scale(screenCoord_scale,screenCoord_scale);

        context2.translate(-100, 30);
        //draw the lock
        //upper parts
        context2.beginPath();
        context2.moveTo(210,140);
        context2.lineTo(210,70);
        context2.bezierCurveTo(210,20,290,20,290,70);
        context2.lineTo(290,140);

        context2.strokeStyle="rgb(100, 100, 100)";
        context2.lineWidth=2*playerRadius;
        context2.stroke();
        //inner circle
        context2.beginPath();
        context2.arc(250,230,100,0,2*Math.PI,1);
        context2.fillStyle="rgb(135, 135, 135)";
        context2.lineWidth=2*playerRadius;
        context2.fill();

        context2.beginPath();
        context2.arc(250,210,20,0,2*Math.PI,1);
        context2.fillStyle="black";
        context2.lineWidth=2*playerRadius;
        context2.fill();

        context2.beginPath();
        context2.rect(244,220,12,50);
        context2.fillStyle="black";
        context2.fill();

        //central circle
        context2.beginPath();
        context2.arc(250,230,100,0,2*Math.PI,1);
        context2.strokeStyle="black";
        context2.lineWidth=2*playerRadius;
        context2.stroke();

        context2.translate(-100,0);

        //reset the scale back to 1*real pixel
        context2.scale(1/screenCoord_scale,1/screenCoord_scale);
        context2.translate(-translation_offset.x,-translation_offset.y);  
    }

    function drawFrame(){
        
        //entire canvas ref frame
        clearCanvas();

        //game ref frame
        context.translate(translation_offset.x,translation_offset.y);
        //scale the drawings
        context.scale(screenCoord_scale,screenCoord_scale);

        context.translate(-100, 30);
        //draw the goal
        context.beginPath();
        context.arc(250,230,100,GoalPos,GoalPos+GoalSize);
        context.strokeStyle="#ff00af";
        context.lineWidth=2*playerRadius;
        context.stroke();

        //draw the cursor
        context.beginPath();
        context.arc(playerCoord.x,playerCoord.y,playerRadius,0,2*Math.PI,1);
        context.fillStyle = "rgb(0,225,0)"; //lime but to increase intensity-contrast with magenta slightly less bright
        context.fill();
        context.translate(100,-30);

        context.translate(-100,0);
        //draw the score
        context.font="30px Arial";
        context.fillStyle = "black";
        context.fillText("Score " + score,200, 28);
        context.translate(100,0);

        //show image frame
        /*context.beginPath();
        context.rect(0,0,300,400);
        context.strokeStyle = "black";
        context.lineWidth=5;
        context.stroke();*/

        //draw the fps counter
        /*context.font="10px Arial";
        context.fillStyle = "black";
        context.fillText(avg_fps + "fps",1, 11);
        if(!(GameTime%5)){
            //update average fps after a number of frames
            avg_fps= round(avgFPS(frametime.diff()),2);
        }*/

        //draw the framecounter
        /*context.font="10px Arial";
        context.fillStyle = "black";
        context.fillText(GameTime,1, 11);*/

        //draw playerangle
        /*context.font="10px Arial";
        context.fillStyle = "black";
        context.fillText(player_angle,1, 11);*/

        //reset the scale back to 1*real pixel
        context.scale(1/screenCoord_scale,1/screenCoord_scale);
        context.translate(-translation_offset.x,-translation_offset.y);  
    }

    function drawFrame_Gameover (){
        context.translate(translation_offset.x,translation_offset.y);
        //scale the drawings
        context.scale(screenCoord_scale,screenCoord_scale);

        context.translate(-100,0);

        //draw background rectangle
        context.beginPath();
        context.rect(150,180,200,50);
        context.fillStyle = "yellow";
        context.fill();

        //draw gameover text
        context.font="30px Arial";
        context.fillStyle = "black";
        context.fillText("GAME OVER",160,220);

        context.translate(100,0);

        //reset the scale back to 1*real pixel
        context.scale(1/screenCoord_scale,1/screenCoord_scale);
        context.translate(-translation_offset.x,-translation_offset.y);
    }

    const round = (number, decimalPlaces) => {
    const factorOfTen = Math.pow(10, decimalPlaces);
    return Math.round(number * factorOfTen) / factorOfTen;
    }

    const floor = (number, decimalPlaces) => {
        var rounded = round(number, decimalPlaces);
        if(rounded>number){
            const factorOfTen = Math.pow(10, -decimalPlaces);
            rounded-=factorOfTen;
        }
        
        return rounded;
    }

</script>
</html>