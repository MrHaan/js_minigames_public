<!--wikipedia on some common color spectra: https://en.wikipedia.org/wiki/List_of_monochrome_and_RGB_color_formats#3-bit_RGB -->
<!-- The 3 bit colors can be used using the following css colors: "red","lime","blue","magenta", "yellow" and "cyan" (and also "black" and "white") -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lock picker game</title>
</head>
<body>
    <canvas id="drawContainer" width="500" height="500" style="border: 3px solid #333;"></canvas>
</body>

<script>
    /* SOME CONSTRAINTS ON THE VARIABLES:
    *** Goalsize must be greater than player diameter, else collision detection may fail
    *** The Goalsize should also not be too large because otherwise the generation loaction constraints may never be met, crashing the game
    */

    const canvasEle = document.getElementById('drawContainer');
    const context = canvasEle.getContext('2d');

    //update the frame at constant framerate
    const fps=60;
    var GameTime=0; // gametime in frames
    var gameClk; //variable holding timer that trigger frame refresh after set amount of time

    var GameState="play";// current state of the game. list of states: play, gameover

    var score=0; //number of hits the player made

    var player_angle=0;     //angle of the player (in rad)
    var playerCoord={x:150,y:250};
    const playerSpeed_init=0.08 * (60/fps); //initial speed of the player. Normalized at 60fps, to make it independent of set framerate
    const playerSpeed_final=1.5*0.08 * (60/fps); //maximum (aka final) speed of the player. Normalized at 60fps, to make it independent of set framerate
    var playerSpeed=playerSpeed_init; //playerspeed in rad per frame
    const playerRadius=15; //radius of the player in px
    var sign=1; //the sign of the direction the player is moving in

    var GoalPos=0; //lowest angle of the goal in rad
    const GoalSize_init=0.8; //inital goalsize (in rad)
    const GoalSize_final=0.35; //final goalsize (in rad)
    var GoalSize=GoalSize_init; //size of the goal in rad

    window.onload = () => {
        generateGoal();
        gameClk = setInterval(updateGamestate,1000/fps);
    }

    function updateGamestate(){
        GameTime++;
        switch(GameState){
            case "play": 
                updatePlayer();
                drawFrame();
            break;
            case "gameover": 
                drawFrame_Gameover();
            break;
            default: console.log("ERROR: The game is not is a valid state..."); 
            break;
        }       

    }

     //declaring eventlisteners
     const mouseDownListener = (event)=>{
        
        switch(GameState){
            case "play": 
                //check whether it was a hit
                if(isCollision()){
                    //if yes, change the sign
                    sign*=-1;

                    //increase difficulty to play
                    nextLevel();
                    //generate new goal
                    generateGoal();
                    //increase score counter
                    score++;
                }
                else{
                    //if no, game over
                    GameState="gameover";
                 }
                break;
            case "gameover": 
                //restart the game
                //do so by reloading the page
                location.reload();
            break;
            default: console.log("ERROR: The game is not is a valid state..."); 
            break;
        }      
        event.preventDefault();
    }

        //binding eventlisteners
    //mouseinputs
    canvasEle.addEventListener('mousedown', mouseDownListener);

    //touch inputs
    canvasEle.addEventListener('touchstart', mouseDownListener);
    
    //calculate coordinates relative to canvas
    const getClientOffset = (event)=>{
        const {pageX, pageY}=event.touches ? event.touches[0]:event;
        
        const y=pageY-canvasEle.offsetTop;
        const x=pageX-canvasEle.offsetLeft;

        return {x,y};
    }

    const clearCanvas = ()=>{
        context.clearRect(0,0,canvasEle.width, canvasEle.height);
    }    

    //update the position of the player
    function updatePlayer(){
        player_angle+=sign*playerSpeed;
        playerCoord.x = 250 + 100*Math.cos(-1*player_angle);
        playerCoord.y = 250 + 100*Math.sin(-1*player_angle);
    }

    //increase the game's difficulty to match the higher level
    function nextLevel(){
        //decrease goal size
        const numSteps_goal=30; //number of steps goalsize take to reach final value
        const numSteps_speed=30; //number of steps (aka levels) to take between initial and maximum player speed

        //decrease goalsize
        //only start increasing difficulty after some level is reached  
        if(score>1){
            //only decrease until the final value is reached
            if(GoalSize>GoalSize_final)
            {
                GoalSize+= (GoalSize_final - GoalSize_init) /numSteps_goal;
            }
            else{
                GoalSize=GoalSize_final;
            }
        }

        //increase playerspeed
        //only start increasing difficulty after some level is reached      
        if(score>numSteps_goal - (numSteps_speed/4))
        {
            //only increase until the maximum value is reached
            if(playerSpeed<playerSpeed_final)
            {
                playerSpeed+= (playerSpeed_final - playerSpeed_init) /numSteps_speed;
            }
            else{
                playerSpeed=playerSpeed_final;
            }
        }
    }

    //generate new position for the goal
    function generateGoal(){
        let GoalPos_old=GoalPos;
        while((Math.abs(GoalPos-GoalPos_old)<GoalSize)){
            GoalPos = GoalPos_old -0.3*Math.PI + 1*Math.PI* Math.random();
        }
        if(GoalPos>2*Math.PI){
            GoalPos-=2*Math.PI;
        }
        if(GoalPos<0){
            GoalPos+=2*Math.PI;
        }
        if(GoalPos+GoalSize>2*Math.PI){
            GoalPos-=GoalSize;
        }
    }

    //checks for collision between player and goal
    function isCollision(){
        //calculate players angles
        var Angle_player_center=Math.atan2(playerCoord.x - 250,playerCoord.y -250);
        //convert the angle from atan2 to the javascript canvas.arc() angle
        if((Angle_player_center>=0)&&(Angle_player_center<=0.5*Math.PI)){
            Angle_player_center=0.5*Math.PI-Angle_player_center;
        }
        if((Angle_player_center<=Math.PI)&&(Angle_player_center>=0.5*Math.PI)){
            Angle_player_center=2.5*Math.PI-Angle_player_center;
        }
        if((Angle_player_center<=0)&&(Angle_player_center>=-1*Math.PI)){
            Angle_player_center=0.5*Math.PI+-1*Angle_player_center;
        }

        var Angle_player_upper=Angle_player_center + Math.asin(playerRadius/100);
        var Angle_player_lower=Angle_player_center - Math.asin(playerRadius/100);

        /*console.log("player angle center: "+Angle_player_center);
        console.log("player angle upper: "+Angle_player_upper);
        console.log("player angle lower: "+Angle_player_lower);
        console.log("goal angle: "+GoalPos);
        var temp=GoalPos+GoalSize;
        console.log("goal angle upper: "+temp);*/

        var GoalPos_upper=GoalPos+GoalSize;
        if(GoalPos_upper>2*Math.PI){
            GoalPos_upper-=2*Math.PI;
        }

        if((Angle_player_upper>=GoalPos) &&(Angle_player_upper<=GoalPos_upper))
        {
            return true;
        }
        if((Angle_player_lower>=GoalPos) &&(Angle_player_lower<=GoalPos_upper))
        {
            return true;
        }
        return false;
        //draw angle from zero to center (for debugging purposes)
        /*context.beginPath();
        context.arc(250,250,100,0,Angle_player_center);
        context.strokeStyle="green";
        context.stroke();*/
    }

    const drawFrame=()=>{
        clearCanvas();
        //canvas background
        context.beginPath();
        context.rect(0,0,canvasEle.width, canvasEle.height);
        context.fillStyle="cyan";
        context.fill();

        //draw the lock
        //upper parts
        context.beginPath();
        context.moveTo(210,160);
        context.lineTo(210,90);

        context.moveTo(290,160);
        context.lineTo(290,90);
        
        context.moveTo(210,90);
        context.bezierCurveTo(210,40,290,40,290,90)

        context.strokeStyle="rgb(100, 100, 100)";
        context.lineWidth=2*playerRadius;
        context.stroke();
        //inner circle
        context.beginPath();
        context.arc(250,250,100,0,2*Math.PI,1);
        context.fillStyle="rgb(135, 135, 135)";
        context.lineWidth=2*playerRadius;
        context.fill();

        context.beginPath();
        context.arc(250,230,20,0,2*Math.PI,1);
        context.fillStyle="black";
        context.lineWidth=2*playerRadius;
        context.fill();

        context.beginPath();
        context.rect(244,240,12,50);
        context.fillStyle="black";
        context.fill();

        //central circle
        context.beginPath();
        context.arc(250,250,100,0,2*Math.PI,1);
        context.strokeStyle="black";
        context.lineWidth=2*playerRadius;
        context.stroke();

        //draw the goal
        context.beginPath();
        context.arc(250,250,100,GoalPos,GoalPos+GoalSize);
        context.strokeStyle="magenta";
        context.stroke();

        //draw the cursor
        context.beginPath();
        context.arc(playerCoord.x,playerCoord.y,playerRadius,0,2*Math.PI,1);
        context.fillStyle = "rgb(0,225,0)"; //lime but to increase intensity-contrast with magenta slightly less bright
        context.fill();

        //draw the score
        context.font="30px Arial";
        context.fillStyle = "black";
        context.fillText("Score " + score,200, 490);

        //draw the framecounter
        /*context.font="10px Arial";
        context.fillStyle = "black";
        context.fillText(GameTime,1, 11);*/
        
    }

    const drawFrame_Gameover = ()=>{
        //draw background rectangle
        context.beginPath();
        context.rect(150,200,200,50);
        context.fillStyle = "yellow";
        context.fill();

        //draw gameover text
        context.font="30px Arial";
        context.fillStyle = "black";
        context.fillText("GAME OVER",160,240);
    }

</script>
</html>